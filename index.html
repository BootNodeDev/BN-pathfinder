<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
    font-family: "Noto Sans", sans-serif;
}
.container { display: flex; flex-wrap: nowrap; }
.descriptor { width: 3.5em; display: inline-block; }
.suggestion { height: 2em; display: flex; flex-direction: row; }
.avatarImage { height: 100%; width: 2em; vertical-align: middle; }
.step { height: 4ex; padding: 1ex; border-bottom: 1px solid black; }
.stepValue { width: 9em; text-align: right; display: inline-block; }
.name { width: 6em; display: inline-block; }
small {
  width: 6em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: inline-block;
  vertical-align: middle;
}
</style>
</head>
<body>
<h1>Pathfinder</h1>
<p>Compute multi-hop transfers in the CirclesUBI graph.<br/>
The computation is done locally, only usernames and avatars are queried from the database.<br/>
The trust graph is updated at irregular intervals, so the information might be out of date.</p>
<p>Number of edges in the graph: <span id="edgeCount">loading...</span></p>
<p>
<div class="container" style="flex-direction: column;">
<div id="fromSelector" class="container">
<span class="descriptor">From:</span><input id="from" type="text" /><div id="fromSuggestion" class="suggestion container"></div>
</div>
<div id="toSelector" class="container">
<span class="descriptor">To:</span><input id="to" type="text" /><div id="toSuggestion" class="suggestion container"></div>
</div>
<div id="toSelector" class="container">
<span class="descriptor">Value:</span><input id="value" type="text" /> (put 0 to compute max value to transact)
</div>
</div>
<button id="compute">compute</button>
<p>Value: <span id="flow">?</span></p>
<p>Steps:</p>
<div id="steps" class="container" style="flex-direction: column;"/>
<script src="./emscripten_build/pathfinder.js"></script>
<script type="text/javascript" language="javascript">
let CirclesAPI = 'https://api.circles.garden/api/';
let GraphAPI = 'https://graph.circles.garden/subgraphs/name/CirclesUBI/circles-subgraph';

let queryUser = function(username, callback) {
    var req = new XMLHttpRequest();
    req.open("GET", CirclesAPI + 'users/?query=' + username, true);
    req.onload = function() {
        if (req.response) {
            callback(JSON.parse(req.responseText));
        }
    };
    req.send(null);
}

let tokenDB = {};

let userByToken = function(token, callback) {
    token = token.toLowerCase();
    if (tokenDB[token] !== undefined) {
        callback(token, tokenDB[token]);
        return;
    }

    var req = new XMLHttpRequest();
    req.open("POST", GraphAPI, true);
    req.onload = function() {
        let safeAddress = JSON.parse(req.responseText).data.token.owner.id;
        tokenDB[token] = safeAddress;
        callback(token, safeAddress);
    }
    req.send(JSON.stringify({
        query: `{token(id:"${token}") {  owner { id } } }`
    }));
}

let loadEdges = function() {
    var req = new XMLHttpRequest();
    req.open("GET", "edges.dat", true);
    req.responseType = "arraybuffer";
    req.onload = function() {
        if (req.response) {
            let edges = new Uint8Array(req.response);
            var ptr = Module._malloc(edges.length);
            var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, edges.length);
            heapBytes.set(new Uint8Array(edges.buffer));
            let numEdges = Module._loadEdges(heapBytes.byteOffset, edges.length);
            Module._free(ptr);
            document.getElementById("edgeCount").innerText = numEdges;
        }
    };
    req.send(null);
};
let setupSuggestions = function(x) {
    let inputBox = document.getElementById(x);
    inputBox.onkeyup = function() {
        let sugBox = document.getElementById(x + "Suggestion");
        sugBox.innerHTML = '';
        queryUser(inputBox.value, function(suggestion) {
            for (user of suggestion.data) {
                sugBox.innerHTML = `<img class="avatarImage" src="${user.avatarUrl}" /><div>@${user.username} <small class="address">${user.safeAddress}</small></div>`;
                sugBox.onclick = function() {
                    inputBox.value = user.safeAddress;
                }
                break;
            }
        });
    };
};

let userDB = {};

let completeUserInfo = function() {
    for (el of document.querySelectorAll('#steps .username')) {
        let safeAddress = el.querySelector('small').innerHTML.toLowerCase();
        if (userDB[safeAddress] !== undefined) {
            let user = userDB[safeAddress];
            el.querySelector('img').src = user.avatarUrl;
            el.querySelector('.name').innerHTML = user.username;
        }
    }
};

let fillUsernames = function(addresses) {
    var req = new XMLHttpRequest();
    let url = CirclesAPI + 'users/?';
    for (addr of addresses) {
        url += '&address[]=' + addr;
    }
    req.open("GET", url, true);
    req.onload = function() {
        if (req.response) {
            for (user of JSON.parse(req.responseText).data) {
                userDB[user.safeAddress.toLowerCase()] = {avatarUrl: user.avatarUrl, username: user.username};
            }
            completeUserInfo();
        }
    };
    req.send(null);
};

let translateTokens = function(tokens) {
    for (token of tokens) {
        userByToken(token, function(token, safeAddress) {
            safeAddress = safeAddress.toLowerCase();
            if (userDB[safeAddress] !== undefined) {
                for (el of document.querySelectorAll('#steps .token')) {
                    if (el.querySelector('small').innerHTML.toLowerCase() == token.toLowerCase()) {
                        el.querySelector('img').src = userDB[safeAddress].avatarUrl;
                        el.querySelector('.name').innerHTML = userDB[safeAddress].username;
                    }
                }
            }
        });
    }
};

let formatValue = function(value) {
    while (value.length <= 18)
        value = '0' + value;
    return value.substr(0, value.length - 18) + '.' + value.substr(value.length - 18, 2);
};
let unformatValue = function(value) {
    let dot = value.indexOf('.');
    let left = value;
    let right = '';
    if (dot >= 0) {
        left = value.substring(0, dot)
        right = value.substring(dot + 1, 18)
    }

    while (right.length < 18)
        right = right + '0'
    return left + right;
};

window.onload = function() {
    loadEdges();
    for (x of ["from", "to"]) {
        setupSuggestions(x);
    }
};
document.getElementById("compute").onclick = function() {
    let from = document.getElementById("from").value;
    if (!from.match(/0x[0-9a-fA-F]{40}/)) {
        from = document.querySelector('#fromSuggestion .address').innerText;
    }
    let to = document.getElementById("to").value;
    if (!to.match(/0x[0-9a-fA-F]{40}/)) {
        to = document.querySelector('#toSuggestion .address').innerText;
    }
    let value = document.getElementById("value").value;
    if (value == 0) {
        value = "115792089237316195423570985008687907853269984665640564039457584007913129639935";
    } else {
        value = unformatValue(value)
    }
    let parameters = JSON.stringify({"from": from, "to": to, "value": value});
    var buffer = Module._malloc(parameters.length + 1);
    Module.stringToUTF8(parameters, buffer, parameters.length + 1);
    let output = Module.UTF8ToString(Module._flow(buffer));
    Module._free(buffer);
    let data = JSON.parse(output);
    document.getElementById("flow").innerText = formatValue(data.flow);
    document.getElementById("steps").innerHTML = '';
    let addressesToQuery = [];
    let tokensToQuery = [];
    for (step of data.transfers) {
        document.getElementById("steps").innerHTML +=
            '<div class="step">' + 
            `<span class="stepValue">${formatValue(step.value)}</span> <span class="username"><img class="avatarImage"/><span class="name"></span> <small>${step.from}</small></span> ->` +
            `<span class="username"><img class="avatarImage"/><span class="name"></span> <small>${step.to}</small></span> (Token: ` +
            `<span class="token"><img class="avatarImage"/><span class="name"></span> <small>${step.token}</small>)` +
            '</div>';
        addressesToQuery = addressesToQuery.concat([step.from, step.to]);
        tokensToQuery.push(step.token)
    }
    fillUsernames(addressesToQuery);
    translateTokens(tokensToQuery);
};
</script>
</body>
</html>
