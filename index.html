<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
    font-family: "Noto Sans", sans-serif;
}
.container { display: flex; flex-wrap: nowrap; }
.descriptor { width: 3.5em; display: inline-block; }
.suggestion { height: 2em; display: flex; flex-direction: row; }
.avatarImage { height: 100%; width: 2em; vertical-align: middle; }
.step { height: 4ex; padding: 1ex; border-bottom: 1px solid black; }
.stepValue { width: 9em; text-align: right; display: inline-block; }
.name { width: 6em; display: inline-block; }
small {
  width: 6em;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: inline-block;
  vertical-align: middle;
}
</style>
<script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
<script src="https://cdn.ethers.io/lib/ethers-5.0.umd.min.js" type="application/javascript"></script>
</head>
<body>
<h1>Pathfinder</h1>
<p>Compute multi-hop transfers in the CirclesUBI graph.<br/>
The computation is done locally, only usernames and avatars are queried from the database.<br/>
The trust graph is updated at irregular intervals, so the information might be out of date.</p>
<p>Number of edges in the graph: <span id="edgeCount">loading...</span></p>
<p>
<div class="container" style="flex-direction: column;">
<div id="fromSelector" class="container">
<span class="descriptor">From:</span><input id="from" type="text" /><div id="fromSuggestion" class="suggestion container"></div>
</div>
<div id="toSelector" class="container">
<span class="descriptor">To:</span><input id="to" type="text" /><div id="toSuggestion" class="suggestion container"></div>
</div>
<div id="toSelector" class="container">
<span class="descriptor">Value:</span><input id="value" type="text" /> (put 0 to compute max value to transact)
</div>
</div>
<button id="compute">compute</button>
<p>Value: <span id="flow">?</span></p>
<p>Transfers:</p>
<div><div id="graph" style="width: 100%; height: 300px;"></div></div>
<div id="steps" class="container" style="flex-direction: column;"/>
<script src="./emscripten_build/pathfinder.js"></script>
<script type="text/javascript" language="javascript">
let CirclesAPI = 'https://api.circles.garden/api/';
let GraphAPI = 'https://graph.circles.garden/subgraphs/name/CirclesUBI/circles-subgraph';

let queryUser = function(username, callback) {
    var req = new XMLHttpRequest();
    req.open("GET", CirclesAPI + 'users/?query=' + username, true);
    req.onload = function() {
        if (req.response) {
            callback(JSON.parse(req.responseText));
        }
    };
    req.send(null);
}

let tokenDB = {};

let userByToken = function(token, callback) {
    token = token.toLowerCase();
    if (tokenDB[token] !== undefined) {
        callback(token, tokenDB[token]);
        return;
    }

    var req = new XMLHttpRequest();
    req.open("POST", GraphAPI, true);
    req.onload = function() {
        let safeAddress = JSON.parse(req.responseText).data.token.owner.id;
        tokenDB[token] = safeAddress;
        callback(token, safeAddress);
    }
    req.send(JSON.stringify({
        query: `{token(id:"${token}") {  owner { id } } }`
    }));
}

let emLoadDB = Module.cwrap("loadDB", 'number', ['array', 'number']);
let emSignup = Module.cwrap("signup", null, ['string', 'string']);
let emTrust = Module.cwrap("trust", null, ['string', 'string', 'number']);
let emTransfer = Module.cwrap("signup", null, ['string', 'string', 'string', 'string']);
let emEdgesFromDB = Module.cwrap("edgesFromDB", null, []);

let loadDB = function() {
    var req = new XMLHttpRequest();
    req.open("GET", "db.dat", true);
    req.responseType = "arraybuffer";
    req.onload = function() {
        if (req.response) {
            let db = new Uint8Array(req.response);
//            let safes = emLoadDB(db, db.length);
            var ptr = Module._malloc(db.length);
            var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, db.length);
            heapBytes.set(new Uint8Array(db.buffer));
            let numSafes = Module._loadDB(heapBytes.byteOffset, db.length);
            Module._free(ptr);
            console.log(`Loaded ${numSafes} safes.`)
            emEdgesFromDB();
        }
    };
    req.send(null);
};

let loadEdges = function() {
    var req = new XMLHttpRequest();
    req.open("GET", "edges.dat", true);
    req.responseType = "arraybuffer";
    req.onload = function() {
        if (req.response) {
            let edges = new Uint8Array(req.response);
            var ptr = Module._malloc(edges.length);
            var heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, edges.length);
            heapBytes.set(new Uint8Array(edges.buffer));
            let numEdges = Module._loadEdges(heapBytes.byteOffset, edges.length);
            Module._free(ptr);
            document.getElementById("edgeCount").innerText = numEdges;
        }
    };
    req.send(null);
};


    const provider = new ethers.providers.JsonRpcProvider('https://xdai-archive.blockscout.com');
    const hubAbi = [
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function balanceOf(address) view returns (uint)",
        "function transfer(address to, uint amount)",
        "function checkSendLimit(address tokenOwner, address src, address dest) view returns (uint256)",
        "function limits(address,address) view returns (uint256)",
        "event Signup(address indexed user, address token)",
        "event OrganizationSignup(address indexed organization)",
        "event Trust(address indexed canSendTo, address indexed user, uint256 limit)",
        "event HubTransfer(address indexed from, address indexed to, uint256 amount)"
    ];
    const tokenAbi = [
        "event Transfer(address indexed _from, address indexed _to, uint256 _value)",
        "event Approval(address indexed _owner, address indexed _spender, uint256 _value)"
    ];

    const hubContract = new ethers.Contract("0x29b9a7fBb8995b2423a71cC17cf9810798F6C543", hubAbi, provider);
  
let uintToAddress = function(value) {
    if (value.length != 66 || value.substr(0, 26) != "0x000000000000000000000000")
        throw("invalid address: " + value);
    value = "0x" + value.substr(26)
    return ethers.utils.getAddress(value);
};

let setupEventListener = async function() {
    console.log("Block: " + await provider.getBlockNumber());
    hubContract.on("Trust", (sendTo, user, limitPercentage) => {
        console.log(`trust ${user} -> ${sendTo} (${limitPercentage}) `);
        // TODO check that limitPercentage is actually a number.
        emTrust(sendTo, user, limitPercentage - 0)
    });
    hubContract.on("Signup", (user, token) => {
        console.log(`signup ${user} ${token}`);
        emSignup(user, token);
    });
    provider.on({ topics: [ ethers.utils.id("Transfer(address,address,uint256)") ] }, (log) => {
        let value = log.data;
        let token = log.address;
        let from = uintToAddress(log.topics[1]);
        let to = uintToAddress(log.topics[2]);
        console.log(`Transfer ${from} -> ${to}: ${value} ${token}`);
        emTransfer(token, from, to, value)
    });
};

let setupSuggestions = function(x) {
    let inputBox = document.getElementById(x);
    inputBox.onkeyup = function() {
        let sugBox = document.getElementById(x + "Suggestion");
        sugBox.innerHTML = '';
        queryUser(inputBox.value, function(suggestion) {
            for (user of suggestion.data) {
                sugBox.innerHTML = `<img class="avatarImage" src="${user.avatarUrl}" /><div>@${user.username} <small class="address">${user.safeAddress}</small></div>`;
                sugBox.onclick = function() {
                    inputBox.value = user.safeAddress;
                }
                break;
            }
        });
    };
};

let userDB = {};

let completeUserInfo = function() {
    for (el of document.querySelectorAll('#steps .username')) {
        let safeAddress = el.querySelector('small').innerHTML.toLowerCase();
        if (userDB[safeAddress] !== undefined) {
            let user = userDB[safeAddress];
            el.querySelector('img').src = user.avatarUrl;
            el.querySelector('.name').innerHTML = user.username;
        }
    }
};

let fillUsernames = function(addresses, callback) {
    var req = new XMLHttpRequest();
    let url = CirclesAPI + 'users/?';
    for (addr of addresses) {
        url += '&address[]=' + addr;
    }
    req.open("GET", url, true);
    req.onload = function() {
        if (req.response) {
            for (user of JSON.parse(req.responseText).data) {
                userDB[user.safeAddress.toLowerCase()] = {avatarUrl: user.avatarUrl, username: user.username};
            }
            completeUserInfo();
            callback();
        }
    };
    req.send(null);
};

let translateTokens = function(tokens) {
    for (token of tokens) {
        userByToken(token, function(token, safeAddress) {
            safeAddress = safeAddress.toLowerCase();
            if (userDB[safeAddress] !== undefined) {
                for (el of document.querySelectorAll('#steps .token')) {
                    if (el.querySelector('small').innerHTML.toLowerCase() == token.toLowerCase()) {
                        el.querySelector('img').src = userDB[safeAddress].avatarUrl;
                        el.querySelector('.name').innerHTML = userDB[safeAddress].username;
                    }
                }
            }
        });
    }
};

let formatValue = function(value) {
    while (value.length <= 18)
        value = '0' + value;
    return value.substr(0, value.length - 18) + '.' + value.substr(value.length - 18, 2);
};
let unformatValue = function(value) {
    let dot = value.indexOf('.');
    let left = value;
    let right = '';
    if (dot >= 0) {
        left = value.substring(0, dot)
        right = value.substring(dot + 1, 18)
    }

    while (right.length < 18)
        right = right + '0'
    return left + right;
};

let drawGraph = function(steps) {
    var nodes = {};
    let labelFor = function(id) {
        let user = userDB[id.toLowerCase()];
        if (user && user.username)
            return user.username;
        else
            return id.substr(0, 8);
    }
    let createNodeContents = function(id) {
        let user = userDB[id.toLowerCase()];
        let node = {id: id, label: labelFor(id)};
        if (user && user.avatarUrl) {
            node['shape'] = 'circularImage';
            node['image'] = user.avatarUrl;
        }
        return node;
    }
    let createNode = function(id) {
        nodes[id] = createNodeContents(id);
    };
    var nodes = {};
    var edges = [];
    for (step of steps) {
        let tokenUser = tokenDB[step.token.toLowerCase()];
        let label = labelFor(tokenUser || step.token);
        createNode(step.from);
        createNode(step.to);
        edges.push({
            from: step.from,
            to: step.to,
            value: step.value,
            label: formatValue(step.value) + " - " + label,
            arrows: "to",
            font: {align: "top"}
        })
    }
    let firstNode = steps[0].from;
    let lastNode = steps[steps.length - 1].to;
    console.log(nodes);
    nodes = new vis.DataSet(Object.values(nodes));
    edges = new vis.DataSet(edges);
    console.log({nodes: Object.values(nodes), edges: edges})
    var network = new vis.Network(
        document.getElementById('graph'),
        {nodes: nodes, edges: edges},
        {}
    );
    network.on('afterDrawing', function() {
        let x = window.innerWidth * .4;
        let data = [{id: firstNode, x: -x, y:0}, {id:lastNode, x: x, y:0}];
        nodes.update(data);
    });
}

window.onload = function() {
    //loadEdges();
    loadDB();
    setupEventListener();
    for (x of ["from", "to"]) {
        setupSuggestions(x);
    }
};
document.getElementById("compute").onclick = function() {
    let from = document.getElementById("from").value;
    if (!from.match(/0x[0-9a-fA-F]{40}/)) {
        from = document.querySelector('#fromSuggestion .address').innerText;
    }
    let to = document.getElementById("to").value;
    if (!to.match(/0x[0-9a-fA-F]{40}/)) {
        to = document.querySelector('#toSuggestion .address').innerText;
    }
    let value = document.getElementById("value").value;
    if (value == 0) {
        value = "115792089237316195423570985008687907853269984665640564039457584007913129639935";
    } else {
        value = unformatValue(value)
    }
    let parameters = JSON.stringify({"from": from, "to": to, "value": value});
    var buffer = Module._malloc(parameters.length + 1);
    Module.stringToUTF8(parameters, buffer, parameters.length + 1);
    let output = Module.UTF8ToString(Module._flow(buffer));
    Module._free(buffer);
    let data = JSON.parse(output);
    document.getElementById("flow").innerText = formatValue(data.flow);
    document.getElementById("steps").innerHTML = '';
    let addressesToQuery = [];
    let tokensToQuery = [];
    for (step of data.transfers) {
        document.getElementById("steps").innerHTML +=
            '<div class="step">' + 
            `<span class="stepValue">${formatValue(step.value)}</span> <span class="username"><img class="avatarImage"/><span class="name"></span> <small>${step.from}</small></span> ->` +
            `<span class="username"><img class="avatarImage"/><span class="name"></span> <small>${step.to}</small></span> (Token: ` +
            `<span class="token"><img class="avatarImage"/><span class="name"></span> <small>${step.token}</small>)` +
            '</div>';
        addressesToQuery = addressesToQuery.concat([step.from, step.to]);
        tokensToQuery.push(step.token)
    }
    fillUsernames(addressesToQuery, function() {
        drawGraph(data.transfers);
    });
    translateTokens(tokensToQuery);
};
</script>
</body>
</html>
